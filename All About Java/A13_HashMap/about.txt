Hashing Fundamentals
Hashing is a technique that maps data of arbitrary size to fixed-size values (hash codes) using a hash function. 
In Java, hashing is fundamental to many collection classes for efficient data storage and retrieval.

Hash Functions

A hash function is any function that can be used to map data of arbitrary size to fixed-size values. In Java:
    Every object has a hashCode() method (inherited from Object class)
    The general contract for hashCode():
        Consistent: multiple invocations should return same value if object hasn't changed
        If two objects are equal (equals() returns true), they must have same hash code
        Unequal objects may have same hash code (hash collision)
        Muultiple input produce same output(Collision)
*****************************************************
TYPES OF HASH FUNCTION 
There are various types of hash functions that are used to place the record in the hash table- 
1 Division Method:
                 The hash function depends upon the remainder of division. Typically the 
                divisor is table length. 
            For eg; If the record 54, 72, 89, 37 is placed in the hash table and if the table size is 10 then  
            h(key) = record % table size 0      
            54%10=4 
            72%10=2   
            89%10=9 
            37%10=7

2 Mid-square Method
    Squares the key and extracts middle digits
    Example: Key=123 → 123²=15129 → hash=512 (middle 3 digits)
3. Multiplication Method
    Uses fractional part of multiplication
    Formula: hash(key) = floor(table_size * (key * A mod 1)) where 0 < A < 1
    Knuth suggests A ≈ (√5 - 1)/2 ≈ 0.618
4. Digit Folding: 
    The key is divided into separate parts and using some simple operation these parts are 
    combined to produce the hash key. 
    For eg; consider a record 12365412 then it is divided into separate parts as 123 654 12 and 
    these are added together 
    H(key) = 123+654+12 
    = 789 
    The record will be placed at location 789 
5. Digit Analysis:
*****************************************************
Collection

Definition: The situation in which the hash function returns the same hash key (home bucket) for 
            more than one record is called collision and two same hash keys returned for different records is 
            called synonym. 
or example,
Consider a hash function.
H(key) = recordkey%10 having the hash table size of 10 
The record keys to be placed are 
131, 44, 43, 78, 19, 36, 57 and 77  
131%10=1 
44%10=4 
43%10=3 
78%10=8 
19%10=9 
36%10=6 
57%10=7 
77%10=7 
Now if we try to place 77 in the hash table then we get the hash key to be 7 and at index 7 already 
the record key 57 is placed. This situation is called collision

**********************************************************
COLLISION RESOLUTION TECHNIQUES 
Probing Techniques 
If collision occurs then it should be handled by applying some techniques. Such a technique 
is called collision handling technique. 
1. Chaining 
2. Open addressing (linear probing) 
3. Quadratic probing 
4. Double hashing 
5. Double hashing 
6. Rehashing 

1. Separate Chaining
        Concept: Each bucket contains a linked list of entries that hash to the same index.
            Keys: 131, 3, 4, 21, 61, 7, 97, 8, 9
            Table Size (D): 10
            Hash Function: H(key) = key % 10
        Index 0: null
        Index 1: [131] → [21] → [61] → null  (131%10=1, 21%10=1, 61%10=1)
        Index 2: null
        Index 3: [3] → null
        Index 4: [4] → null
        Index 5: null
        Index 6: null
        Index 7: [7] → [97] → null
        Index 8: [8] → null
        Index 9: [9] → null 
2. Linear Probing
    If slot is occupied, check next sequential slot.
    Insertion Process:
    131%10=1 → Index 1
    3%10=3 → Index 3
    4%10=4 → Index 4
    21%10=1 → Index 1 (occupied) → Try 2
    61%10=1 → Index 1 (occupied) → Try 2 (occupied) → Try 3 (occupied) → Try 4 (occupied) → Try 5
    7%10=7 → Index 7
    97%10=7 → Index 7 (occupied) → Try 8
    8%10=8 → Index 8 (occupied) → Try 9
    9%10=9 → Index 9 (occupied) → Try 0
    final Table Index 0: [9]
                Index 1: [131]
                Index 2: [21]
                Index 3: [3]
                Index 4: [4]
                Index 5: [61]
                Index 6: null
                Index 7: [7]
                Index 8: [97]
                Index 9: [8]
3. Quadratic Probing
        Probe sequence: (hash + i²) % D, where i=1,2,3,...
        Insertion of 61 (most interesting case):
            61%10=1 → Index 1 (occupied by 131)
            Try (1 + 1²) = 2 → Index 2 (occupied by 21)
            Try (1 + 2²) = 5 → Index 5 (empty)
            final Table Index 0: null
                        Index 1: [131]
                        Index 2: [21]
                        Index 3: [3]
                        Index 4: [4]
                        Index 5: [61]
                        Index 6: null
                        Index 7: [7]
                        Index 8: [97]
                        Index 9: [8]
4. Double Hashing
    Using second hash: H2(key) = 7 - (key % 7)
    H1(key)=key mod table_size
    H2(key)=M-(key mod M)
    Insertion of 61:
        H1 = 61%10 = 1 (occupied)
        H2 = 7 - (61%7) = 7-5 = 2
        Probe sequence: (1 + 1*2)=3 → (1 + 2*2)=5 → (1 + 3*2)=7 → ...
    Index 0: null
    Index 1: [131]
    Index 2: null
    Index 3: [3]
    Index 4: [4]
    Index 5: [61]
    Index 6: null
    Index 7: [7]
    Index 8: [97]
    Index 9: [9]

5.Rehashing Process
    When: Load factor (elements/size) exceeds threshold (typically 0.75)
    How:
        Create new larger table (usually 2x current size)
        For each element in old table:
            Recompute hash using new size
            Insert into new table
        Discard old table
    Example:
    Initial table (size=7) with load factor 6/7 ≈ 0.86 > 0.75
    New size = next prime after 14 → 17
    700%17=3, 50%17=16, 85%17=0, 73%17=5, 101%17=16 (collision), 92%17=7, 76%17=8
    New table (size=17):
    [85, _, _, 700, _, 73, _, 92, 76, _, _, _, _, _, _, 50, 101, _]